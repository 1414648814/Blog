# 前言

在没有理解TCP连接是如何建立和终止之前，我想你可能并不会使用connect，accept，close这三个函数并且使用netstat程序来调试应用。所以掌握TCP连接的建立和终止势在必行。

# 三次握手

![](http://i4.buimg.com/567571/7bab5a80bb3fccc6.png)

1. 客户端首先通过调用connect函数发起主动打开（服务器为被动打开），这导致客户端TCP发送一个**SYN同步分节（Synchronize Sequence Numbers）**，告诉服务器将在连接中发送的数据的初始序列号，如图为 J；（SYN分节不携带数据，其所在的IP数据报只含有一个IP首部、一个TCP首部以及可能有的TCP选项）

2. 服务器需要对客户端的请求进行确认，同时自己也发送一个SYN分节（包含服务器将在同一连接中发送的数据的初始序列号）

3. 客户端进行确认。


为什么发送加一的序列号呢？因为这是发送这一端所期待的下一个序列号，而且SYN占据一个字节的序列号空间；

# 四次挥手

![](http://i1.piimg.com/567571/e0966a60363af061.png)

在步骤2和步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是又可能，这成为半关闭。

这个图只是展示了客户端执行主动关闭的情况，不过无论是客户端还是服务器端，任何一方都可以执行主动关闭。


# TCP状态转换图

在理解了前面的知识以后，再来看总体的状态转换图就会简单很多。

TCP为一个连接定义了11种状态，并且TCP规则规定如何基于当前状态及在该状态下所接收的分节从一个状态转换到另一个状态。

```
LISTEN ：监听来自远方TCP端口的连接请求。
SYN-SENT ：在发送连接请求后等待匹配的连接请求。
SYN-RECEⅣED ：在收到和发送一个连接请求后等待对连接请求的确认。
ESTABLISHED ：代表一个打开的连接，数据可以传送给用户。
FIN-WAIT-1 ：等待远程TCP的连接中断请求，或先前的连接中断请求的确认。
FIN-WAIT-2 ：从远程TCP等待连接中断请求。
CLOSE-WAIT ：等待从本地用户发来的连接中断请求。
CLOSING ：等待远程TCP对连接中断的确认。
LAST-ACK ：等待原来发向远程TCP的连接中断请求的确认。
TIME-WAIT ：等待足够的时间以确保远程TCP接收到连接中断请求的确认。
CLOSED ：没有任何连接状态。
```

TCP连接过程是状态的转换，促使发生状态转换的是用户调用：OPEN，SEND，RECEⅣE，CLOSE，ABORT和STATUS。传送过来的数据段，特别那些包括以下标记的数据段SYN，ACK，RST和FIN。还有超时，上面所说的都会时TCP状态发生变化。

![](http://i2.buimg.com/567571/83df4fe2cfd36ed6.png)

图中粗实线代表的是客户端状态转换，虚线代表的是服务器状态转换。

我们从图中可以发现两种特殊的情况，分别是同时打开和同时关闭，前者发生在两端几乎同时发送SYN并且这两个SYN在网络中交错的情形下，后者发送在同时发送FIN的情形下。

## 同时打开

![](http://i2.buimg.com/567571/96a0451cb50df75b.png)

很明显，这个连接的过程经历四次数据交换，但是一个典型的连接建立只需要3次。

从状态转换图中可以发现，TCP在遇见这种协议的时候，只会打开一条连接，比如图中是由客户端做主动打开。

## 同时关闭

![](http://i2.buimg.com/567571/cc2a123bfdfa7acb.png)

在发送程序后则会进入到 FIN_WAIT_1 状态。在收到对端的FIN后，回复一个ACK，会进入CLOSING状态。在收到对端的ACK后，进入TIME_WAIT状态，也就是说，这中间不会在存在半关闭的状态。


# 推荐

[在线画图工具](https://www.draw.io/)，可以存在谷歌云盘，还可以现场导出图片和PDF