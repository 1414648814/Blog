# linux中的同步原语：

mutex：互斥锁
semaphores：读者／写者信号量
seqlocks：顺序锁
atomic operations：原子操作
spinlock：自旋锁，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等(自旋)阻塞状态。
队列自旋锁：自旋锁的特殊类型

---

多线程开发的最基本概念包括3点：线程、互斥锁、条件。线程的操作又包括创建、退出、等待3种；互斥锁的操作则包括创建、销毁、加锁、解锁；条件操作包括创建、销毁、触发、广播、等待。

多线程开发API
![](http://i2.muimg.com/567571/43c8d4dc6e658791.png)

---

解决竞争条件则通过加锁再解锁，但是需要注意死锁和活锁问题。
* 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
	
发生条件：	

	* 互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。
	* 请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。
	* 不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。
	* 环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,...pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）

解决办法：等待对方释放加锁的资源而无法运行，可以通过要求所有线程都必须按照相同的顺序来获得锁的方法解决；

* 活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源

* 饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。这个现象出现的原因在于操作系统不公平的分配原则。


---

* 空闲指针：指针指向的存储区的生存期已经结束，也就是指向的地址已经释放掉了，但是指针的生存期并没结束；
	
	出现的情况包括：
	1. 函数返回一个局部变量的地址；
	2. 删除动态分配的对象之后并没将其进行指向0，其会指向一个任意的地址；

	解决：
	1. 返回全局变量的地址；
	2. 删除后指向0；


* 野指针：没有被正确的初始化而指向一个随机的地址；

一个是释放了后没有正确的处理，一个是一开始就没有正确的处理。

---

* auto_ptr：被拷贝之后，将会失去原来所指向的资源的所有权（c++11废弃）；
* scoped_ptr：不能用于拷贝和赋值，拥有原来指向的资源的所有权，并且永远不会放弃这个所有权（boost）；
* shared_ptr：可以共享所有资源的所有权；
* unique_ptr：和scoped_ptr类似，但是unique_ptr支持转移的所有权；


---

RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配(获取)，同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题

当一个函数需要通过多个局部变量来管理资源时，RAII就显得非常好用。因为只有被构造成功(构造函数没有抛出异常)的对象才会在返回时调用析构函数，同时析构函数的调用顺序恰好是它们构造顺序的反序，这样既可以保证多个资源(对象)的正确释放，又能满足多个资源之间的依赖关系。

---

智能指针的循环引用

```cpp
class B;
class A
{
public:
　　shared_ptr<B> m_b;
};
 
class B
{
public:
　　shared_ptr<A> m_a;
};
 
int main()
{
　　while (true)
　　{
　　　　shared_ptr<A> a(new A); //new出来的A的引用计数此时为1
　　　　shared_ptr<B> b(new B); //new出来的B的引用计数此时为1
　　　　a->m_b = b; //B的引用计数增加为2
　　　　b->m_a = a; //A的引用计数增加为2
　　}
 
　　//b先出作用域，B的引用计数减少为1，不为0，所以堆上的B空间没有被释放，且B持有的A也没有机会被析构，A的引用计数也完全没减少
　　//a后出作用域，同理A的引用计数减少为1，不为0，所以堆上A的空间也没有被释放
 
}

```

解决方法：使用弱引用指针`weak_ptr`来打破循环，在任意一个类中使用weak_ptr替代shared_ptr即可。

---

如果程序中需要把this通过函数返回一个创建的`shared_ptr`的this，为了避免多个多个独立的`shared_ptr`指向同一份资源，将类继承到enable_shared_from_this上，并且通过函数`shared_from_this()`来返回。如下：

```cpp
class Widget : public std::enable_shared_from_this<Widget> {
    std::shared_ptr<Widget> GetPtr() {
        return shared_from_this();
    }
};

int main() {
    auto widget = std::make_shared<Widget>();
    btn->GetPtr();
}

```

其执行顺序为，先调用`enable_shared_from_this`的构造函数，接着调用`Widget`的构造函数，再调用shared_ptr的构造函数初始化`weak_ptr weak_this_`，最后才调用`GetPtr`函数。

使用注意：

1. 不能在构造函数中使用shared_from_this，因为构造类的时候，还没有将其交给shared_ptr交管；
2. 统一使用智能指针，不能一部分使用原始指针；

---

线程同步的四个原则：

	1.	首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑immutable对象（不可修改的对象）；实在不行才暴露可修改的对象，并用同步措施来充分保护它。
	2.	其次是使用高级的并发编程构件，如TaskQueue、Producer-Consumer Queue、CountDownLatch等等。
	3.	最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。
	4.	除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs. mutex。

---

互斥锁和条件变量的封装实现（比较低层的线程安全实现方式）
线程安全的Singleton实现（利用Pthreads库实现）

mutex和condition都是非常底层的同步原语，主要用来实现更高级的并发编程工具，并不鼓励到处使用。

* 线程同步的四项原则，尽量用高层同步设施（线程池，队列，倒计时）；
* 使用普通互斥器和条件变量来完成剩余的同步任务，采用RAII 和 Scoped Locking；

---

Linux中进程间通信包括：匿名管道、具名管道、POSIX消息队列、共享内存、信号等等；

首选Sockets，原因在于：可以跨平台，具有伸展性。

---

线程正常退出的方式只有一种就是自然死亡，任何从外部强行终止线程的做法都是错误的，因为如果强行终止线程会导致其没有机会清理资源，也没有机会释放已经持有的锁，而别的线程访问锁的时候会立马会陷入死锁。

---

为了简单，多线程程序应该遵循的原则是：每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种`race condition`；一个线程可以操作多个文件描述符，但是一个线程不能去操作别的文件拥有的文件描述符。

多线程编程原则：

1. 线程是宝贵的。一个程序可以使用几个或几十个线程，但一台机器上不应该同时运行几百个、几千个线程，这会大大的增加内核scheduler的负担，降低整体性能。
2. 线程的创建和销毁是有代价的。最好一开始就创建所需线程并一直反复使用，不要在运行期间反复创建、销毁线程，如果必须要这么做，其频度最好能降到1分钟1次。
3. 每个线程应该有明确的职责。例如 IO 线程或计算线程。
4. 线程之间的交互应该尽量简单，理想情况下，线程之间只用消息传递的方式交互，如果必须要用锁，那么最好避免一个线程同时拥有两把或者更多的锁，这样可以防止死锁（？）
5. 考虑清楚一个 mutable shared 对象将会暴露给哪些线程，每个线程是读还是写，是否并发。

---



