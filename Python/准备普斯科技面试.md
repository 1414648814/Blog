# 面试普思科技

## python爬虫

### 项目的理解

项目中**核心代码**就是

```python
 # 传入某一页的索引获得页面代码
def getPage(self,pageIndex):
    try:
        url = 'http://www.qiushibaike.com/hot/page/' + str(pageIndex)
        request = urllib2.Request(url,headers=self.headers)
        response = urllib2.urlopen(request)
        pageCode = response.read().decode('utf-8')
        return pageCode
    except urllib2.URLError,e:
        if hasattr(e,"reason"):
            print "error",e.reason
            return None

```

**我使用的是urllib2这个HTTP客户端库，通过Request方法去创建url对应的Request对象，然后设置好一个URL的headers；接着使用urlopen这个方法去访问request对象，将返回的值通过read读取后再进行解析,解析则是通过re模块进行正则匹配后取出匹配的结果；
**

### 扩展
    
* 为什么urllib2和urllib放在一起用？

    urllib模块可以提供进行urlencode的方法，该方法用于GET查询字符串的生成，urllib2的不具有这样的功能。这就是urllib与urllib2经常在一起使用的原因。
    
---

* 用的什么匹配模式

    使用的是懒惰匹配模式，就是匹配尽可能少的字符，这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复

* 使用urllib2
    
```python
request = urllib2.Request(uri)
request.add_header('User-Agent', 'fake-client')
response = urllib2.urlopen(request)
```

* User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求

* Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。常见的取值有：

application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用
application/json ： 在 JSON RPC 调用时使用
application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用
在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务

urllib2 对 Cookie 的处理也是自动的。如果需要得到某个 Cookie 项的值，可以这么做：

```python
import urllib2
import cookielib

cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))
response = opener.open('http://www.google.com')
for item in cookie:
    if item.name == 'some_cookie_item_name':
        print item.value
```

---

* 爬虫相关操作
    [爬虫1](http://itindex.net/detail/55575-python-%E6%80%BB%E7%BB%93)
    
    [爬虫2](https://piaosanlang.gitbooks.io/spiders/10day/section10.7.html)

* 现场写Python
    [网址](https://gist.github.com/jungledrum/5438373)

---

## 操作系统

### 进程

进程是程序的一次执行过程，是系统进行资源分配和调度的一个独立单位；
具有动态性，并发性，独立性，异步性，结构性；

一般来说，有五种进程状态，包括 新建、就绪、运行、终止、阻塞；

![](http://odwv9d2u8.bkt.clouddn.com/17-4-11/50423736-file_1491849059392_156e.png)


[进程转换](http://c.biancheng.net/cpp/html/2589.html)

这里应该是运行指向的阻塞！；

### 进程和线程的区别

* 调度：线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位；
* 并发性：不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，但是由一个进程中的线程切换到另一个进程的线程时，依然会引起进程切换；
* 拥有资源：进程可以拥有自己的资源，线程自己不拥有系统资源，但可以访问其隶属进程的资源；
* 系统开销：由于在创建或者撤销进程时，系统都要为之分配或者回收资源，因此，操作系统所付出的开销将显著大于在创建或者撤销线程时的开销；同样的，在进行进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的进程的CPU环境的设置，而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作；此外，由于统一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现也变得比较容易；

### 内存池、进程池、线程池

* 池化技术：提前保存大量的资源，以备不时之需以及重复使用；
* 线程池：先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要一个开辟一个线程去做具体的工作时，就会唤醒线程池中的某一个睡眠线程，让它去做具体工作，当工作完成后，线程又处于睡眠状态，而不是将线程销毁；
* 进程池：和线程池同理‘
* 内存池：内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的真正内存释放。


## 网络

### 如何实现透明传输



### TCP通过哪些措施，保证传输可靠？

数据可靠性传输包括下面内容：

* 能够处理数据传输过程中被破坏的问题
* 能够处理重复数据接收问题
* 能够发现数据丢失以及对此进行有效解决
* 能够处理接收端数据乱序到达问题

TCP协议规范采用**数据重传和数据确认应答机制**完成TCP协议的可靠性数据传输；

数据超时重传和数据应答机制的基本前提时对每个传输的字进行编号，即序列号；

**数据超时重传**是发送端在某个有效数据包发送出去，在一段固定时间后如果没有收到该数据包的确认应答，则认为该数据包在传输过程中丢失，并且重新发送该数据包；

通常发送端自身会自发的重传这些未得到对方确认的数据，但是由于重传机制采用指数退避算法，每次重传的间隔时间均会加倍，所以通过发送方主动重传机制恢复的时间较长，而接收端通过不断发送这些丢失数据的请求，发送端在接收到三个这样的请求数据包后（三个请求数据包中具有同一个请求序列号，也就是前面提到的应答序列号），会立即触发对这些数据的重新发送。

**数据确认应答**是指接收端在成功接收到一个有效数据包后，发送一个确认数据包给发送端主机，该确认应答数据包中所包含的应答序列号即指已经接收到的数据中最后一个字节的序列号加1，加1的目的在于指出此时接收端期望接收的下一个数据包中第一个字节的序列号，

---

通过下列方式提供可靠性：

* 面向字节流和缓存机制：应用数据被分割成TCP认为最适合发送的数据块，和UDP完全不同（应用程序产生的数据长度将保持不变）

* 超时重发和确认机制：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。当TCP收到发自TCP连接另一端的数据，它将发送一个确认。TCP有延迟确认的功能，在此功能没有打开，则是立即确认。功能打开，则由定时器触发确认时间点。

* 检验和机制：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）

* 字节编号机制：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。

* 自动丢弃重复机制：既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。

* 流量控制：TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

---





