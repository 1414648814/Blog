# C++基础知识

## 有符号类型和无符号类型的区别

* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模之后的余数。当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的；

* 同时存在带符号数和无符号数，当带符号类型取值为负的时候会出现异常结果，这是因为带符号数会自动转换成无符号数。

## 引用与指针的区别

* 指针本身就是一个对象，可以对其进行拷贝和赋值，在指针的生命周期内可以先后指向多个对象。

* 引用只是对象起的一个别名，定义的时候必须要经过初始化，也无法进行拷贝和赋值。

* 注意的是，void\*是一种特殊的指针类型，可以存放任意对象的地址。但是因为我们对其地址存放的对象的类型并不清楚，所以也不能直接操作void\*指针所指的对象。


## static关键字

这个分为局部变量、全局变量或函数、成员变量或函数；

* **局部变量**：存储在静态存储区，其生命周期不再局限于当前作用域，而是整个程序的生存期。
* **全局变量、函数**：不同于普通的全局（可以通过extern来访问），static其作用域为当前的cpp文件，其他的cpp文件不能访问该变量和函数。
* **成员变量、函数**：该变量和函数属于一个类，而不是该类的某个实例化对象。


## const限定符

### const作用

const限定符包括对参数和对返回值还有对常量还有指针。

* **常量**：在定义常量时必须对其进行初始化，此后其的值不允许再发生改变。
* **指针**：如果const出现在\*的左边，则说明其为常量对象，指针可以发生改变，但是指向的对象不能改变；但是如果const出现在\*的右边，则说明其为常量指针，指针不能发生改变，但是指向的对象可以发生改变。
* **函数**：说明是一个常量函数，不能修改类的成员变量。
* **返回值**：使得返回值为常量。

### const和define的区别

const拥有数据类型，可以进行类型检查，并且进行调试，但是define没有数据类型，并且只进行字符替换，也没有类型检查。

## 数组与指针的区别

* 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
* 用运算符sizeof可以计算出数组的容量（字节数），但是如果是指针的话，只能够得到一个指针变量的字节数，而不是指向的内存容量。
* C++编译系统将形参数组名一律作为指针变量来处理。实际上在函数调用时并不存在一个占有存储空间的形参数组，只有指针变量。

> 为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址；但是，当用常量内存初始化数组时，情况却有所不同。这是因为字符串数组会将字符串的内容拷贝到字符串数组中，而不是像指针一样去指向内存中已经存在的拷贝，因而导致指向的同一个地址。

## sizeof运算符

在我看来，分为这么几种：数组类型，指针类型，联合类型，结构类型或类类型等。

* 数组类型：数组的总字节数。
* 指针类型：如果是指向数组的指针，其结果是该指针的字节数；又或者是函数中的数组形参或者函数类型的形参，其结果也是指针的字节数。（如果在32位的机器上，指针占用4字节，如果是64位的机器上，则占用8字节）
* 联合类型：采用成员中最大长度对齐。
* 结构类型或者类类型：这种类型对象的总字节数，包括任何填充在内。
    * 类中的静态成员不会对结果产生影响，因为静态变量的存储位置（静态存储区）与结构或者类的实例地址（栈上）无关；
    * 没有成员变量的类的大小为1，因为必须保证类的每一个实例在内存中都有唯一的地址；
    * 有虚函数的类都会建立一张虚函数表，表中存放的是虚函数的函数指针，这个表的地址存放在类中，所以不管有几个虚函数，都只会占据一个指针的大小；


## 四个强制类型转换

* **static\_cast**：任何不具有明确定义的类型转换，只要不包含底层const，都可以使用static\_cast；
* **const_cast**：去除const属性，只能改变运算对象的底层const。常用于有函数重载的上下文中；
* **reinterpret_cast**：强制类型转换，用在任意指针（或引用）类型之间的转换，以及指针与足够大的整数类型之间的转换，从整数类型到指针类型，无视大小；
* **dynamic_cast**：主要用来执行“安全向下转型”，也就是用来决定某个对象是否归属继承体系中的某个模型，主要用于多态之间的转换；
    * 安全的基类和子类之间的转换；
    * 必须要有虚函数；
    * 相同基类不同子类之间的交叉转换，但结果是NULL；

## 结构体的内存对齐

## malloc/free 与 new/delete的区别

* malloc与free是C/C++中的标准库函数，而new与delete是C++的运算符，它们都可以用于申请和释放动态内存。
* new是用来完成动态内存分配和初始化工作的运算符；delete是一个能完成清理和释放内存工作的运算符。
* new建立的是一个对象，而malloc分配则是一块内存。


## String类的实现

## 派生类中构造函数与析构函数的调用顺序

**构造函数：**

* 父类（如果有多个基类，则构造函数的调用顺序是某类派生表中出现的顺序，而不是它们在成员初始化表中的顺序）
* 派生类

**析构函数（相反）：**

* 派生类
* 父类

## 虚函数的实现原理

编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令（跳转指令）的地址。类的每个虚函数占据虚函数表中的一块，如果类中有N个虚函数，那么其虚函数表就有4N字节的大小；

编译器在有虚函数的类的实例中创建了一个指向虚函数表的指针，该指针通常存在于对象实例中最前面的位置（这是为了保证取到虚函数表有最高的性能）。这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并且找到相应的函数。

## 哪些函数适合声明为虚函数

* 当存在类继承并且析构函数中有必需要进行的操作的时候（如需要释放某些资源，或者执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄漏或达不到预期的结果；

* 内联函数不能为虚函数，内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开；

* 构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过没有动态效果，只会调用本类中的对应函数；
* 静态成员函数不能为虚函数：静态成员函数是以类为单位的，与具体对象无关，虚对象是与对象动态绑定的。

## 虚继承的实现原理

为了解决从不同途径继承而来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。

## 程序加载时的内存分布

### 堆和栈的区别

* 申请管理方式
    * 堆：由程序员控制申请和释放，容易造成内存泄漏；
    * 栈：由编译器自动管理，无需我们手动控制；
* 申请后系统的响应
    * 栈：只要栈的剩余空间大于所申请的空间大小，系统就会为其自动分配空间，否则则会进行系统提示栈溢出；
    * 堆：操作系统中会有一个记录空闲地址的链表，当进行申请的时候，系统会遍历该链表，找到第一个空闲空间大于申请空间的结点，接着把该结点删除，分配申请空间；当进行删除的时候，因为在申请空间的时候，该空间的首地址还记录了申请空间的大小，便于删除，在删除了以后，系统会自动的将空闲的部分重新整合起来放到链表中；
* 申请大小的控制
    * 栈：在Windows中，栈是向低地址扩展的数据结构，是一块连续的内存区域，也就是说，栈顶的位置和栈的最大容量是系统预定好的；
    * 堆：向高地址进行扩展的数据结构，是一块不连续的内存区域，因为内存空间是通过链表进行记录的，链表的遍历方向是由低地址向高地址，堆的大小受限于系统有效的虚拟内存；由此可见，堆获得的空间比较灵活，也比较大；
* 申请效率的比较
    * 栈：由系统分配，速度较快，但是是程序猿无法进行控制的；
    * 堆：是new分配的内存，一般速度会比较慢，而且最容易产生碎片；
* 总结
堆由于大量new/delete的使用，容易造成大量的内存碎片，并且可能会引发用户态和核心态的切换，代价会变得更昂贵，但是也有好处，申请的空间较为灵活，也比较大；相比而言，栈的调用更加安全且代价更小一些，比如函数的调用也是通过栈来完成的，函数在调用过程中的参数、返回地址、ebp、局部变量都是通过栈来存放的。

## 三种智能指针

智能指针区别于常规指针的方式在于管理底层指针的方式：shared\_ptr允许多个指针指向一个同一个对象，unique_ptr则独占所指向的对象；wark_ptr：是一种弱引用，指向shared_ptr所管理的对象；

* **shared_ptr**：是一个类对象，封装了指针对象，重载了两种常见的指针操作符＊和－》。内部采用了引用计数的机制；当指向内部对象的引用计数为0的时候，内部对象则进行销毁，它允许多个shared_ptr指针共享同一个堆内存分配的对象。操作use_count()返回与内部对象共享对象的智能指针的数量（可能会很慢，主要用于调试）；

* **unique_ptr**：和shared_ptr不同的是，某一个时刻只有一个unique_ptr指向一个给定对象，当其unique_ptr被销毁的时候，它指定的对象也会被销毁，同时，没有类似make_shared的标准库函数返回一个unique_ptr，当我们定义一个unique_ptr的时候，需要将其绑定到一个new返回的指针上，但是和shared_ptr相同的是，初始化unique_ptr必需采用直接初始化的形式；操作release是指将放弃对指针的控制权，返回一个空的指针；操作reset是指释放指针所指向的内部对象；

* **weak_ptr**：是一种不控制指向对象生存期的智能指针，他指向一个shared_ptr管理的对象，将一个weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数，当最后一个指向shared_ptr的引用计数为0的时候，其会被自动销毁，即使有weak_ptr指向，该对象还是会被释放；主要用途在于配合shared_ptr的使用，解决在使用shared_ptr中出现的循环引用（引用计数不能减到0，不会释放内存，导致内存泄漏）

## C++对象内存模型

在C++中，有两种数据成员：static和non-static，还有三种类成员函数：static、non-static、virtual；

对象内存模型分为继承和非继承；其中继承又分为单一继承、多重继承、重复继承和虚继承；

推荐一篇[深度好文](http://www.cnblogs.com/QG-whz/p/4909359.html#_label4)

## 乱七八糟

全局对象：在程序启动时分配，在程序结束时进行销毁；局部自动对象：进入定义所在的程序块时创建，在离开块时销毁；局部static对象：在第一次使用时创建，在程序结束时销毁；


[面试题目](http://www.jianshu.com/p/cc1bdada166f)

